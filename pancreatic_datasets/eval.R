library(Matrix)
library(ggplot2)
library(stringr)
library(MASS)

## --------------------------------------------------------------------------------------------------------------------------------
##   Some notes
##     - Conversion between data representations (e.g. TPM) described in this paper:
##         https://rnajournal.cshlp.org/content/early/2020/04/13/rna.074922.120.full.pdf
##     - I'm visually validating cell types by looking at levels of insulin (Ins2), glucagon (Gcg), and somatostatin (Sst). This
##       seems like standard pracice. Per DiGruccio et al. paper:
##         "Cells that had an RPKM value > 10 k of either Sst, or Ins2, or Gcg were defined as delta, beta, or alpha cells,
##         respectively."
## --------------------------------------------------------------------------------------------------------------------------------

setwd("C:/Users/kim/Desktop/beta_cells")

bulk_dir <- "Adriaenssens2016"
sc_dir <- "MarquinaSanchez2020"

# These are quality control settings used by Marquina-Sanchez et al.
MIN.UMIS <- 500
MIN.GENES <- 200
SCALE.FACTOR <- 10^6

show_images <- TRUE

## --------------------------------------------------------------------------------------------------------------------------------
##   FUNCTIONS
## --------------------------------------------------------------------------------------------------------------------------------

# Assumes gene_idx is 0-indexed and sample_IDs is a set of cell barcodes.
# pull_expr_vector <- function(mat_obj, gene_idx, sample_IDs = NULL) {
#   sample_idx <- 1:ncol(mat_obj)
#   if(!is.null(sample_IDs)) {
#     sample_idx <- sort(which(colnames(sc) %in% sample_IDs))
#   }
#   # Remember to switch indexing back to 1-indexing for this accessor!
#   mat_obj[gene_idx + 1, sample_idx]
# }

umi_to_tpm <- function(mat_obj) {
  tpm.sc <- t(t(mat_obj) * SCALE.FACTOR/Matrix::colSums(mat_obj))
  as(tpm.sc, "dgTMatrix")
}

## --------------------------------------------------------------------------------------------------------------------------------
##   PARSE BULK DATA
## --------------------------------------------------------------------------------------------------------------------------------

bulk <- read.table(file.path(bulk_dir, "GSE76017_data_geo.txt"), sep = "\t", header = TRUE, stringsAsFactors = FALSE)

# The bulk data has "duplicate" gene names. We'll average these for now but we should probably take a closer look at this.
# I assume they're isoforms of the same gene. Maybe we want to think of another way of dealing with these.
# The below takes ~2 min. to run.
unique_genes <- sort(unique(bulk$gene_short_name))
bulk.collapsed <- matrix(NA, length(unique_genes), ncol(bulk)-2)
for(ug in 1:length(unique_genes)) {
  gene_name <- unique_genes[ug]
  selected_rows <- bulk[bulk$gene_short_name == gene_name,3:ncol(bulk)]
  collapsed_rows <- colMeans(selected_rows)
  bulk.collapsed[ug,] <- collapsed_rows
}
rownames(bulk.collapsed) <- unique_genes
bulk_celltypes <- unname(sapply(colnames(bulk)[3:ncol(bulk)], function(x) {
  str_match(x, "^([[:alpha:]]+)\\.")[1,2]
}))
colnames(bulk.collapsed) <- bulk_celltypes
bulk <- bulk.collapsed
rm(bulk.collapsed)

sst_idx_bulk <- which(rownames(bulk) == "Sst") # delta
ins2_idx_bulk <- which(rownames(bulk) == "Ins2") # beta
gcg_idx_bulk <- which(rownames(bulk) == "Gcg") # alpha
gapdh_idx_bulk <- which(rownames(bulk) == "Gapdh") # housekeeping

df <- data.frame(expression = unlist(bulk[sst_idx_bulk,]), gene = "Sst", celltype = bulk_celltypes)
df <- rbind(df, data.frame(expression = unlist(bulk[ins2_idx_bulk,]), gene = "Ins2", celltype = bulk_celltypes))
df <- rbind(df, data.frame(expression = unlist(bulk[gcg_idx_bulk,]), gene = "Gcg", celltype = bulk_celltypes))
df <- rbind(df, data.frame(expression = unlist(bulk[gapdh_idx_bulk,]), gene = "Gapdh", celltype = bulk_celltypes))
p <- ggplot(df, aes(x = as.factor(celltype), y = expression)) +
  geom_boxplot() +
  facet_wrap(~ gene, scales = "free") +
  xlab("Cell type") +
  ylab("Bulk reads")
if(show_images) {
  show(p)
} else {
  ggsave("01_marker_expression_in_bulk.png", p, units = "in", dpi = 100, height = 4, width = 4)
}

## --------------------------------------------------------------------------------------------------------------------------------
##   PARSE SINGLE-CELL DATA
## --------------------------------------------------------------------------------------------------------------------------------

# Parse the annotation file.
sc_annot <- read.table(file.path(sc_dir, "GSE142465_MouseLTI_CellAnnotation_final.tsv"), sep = "\t", header = TRUE, stringsAsFactors = FALSE)
# Some stats:
#   - Annotations include `celltype` and `celltype2`. These agree in 92% of cells. I think they're generated by two sets of
#     heuristics. I'm arbitrarily using cells in the intersection of these two labels.
#   - Approx. 97% of sample IDs (barcodes) are shared between the count data and annotation files. The paper seems to imply the
#     rest might have been contaminated, very poor quality, etc.

# The below code was copied from 10X's website:
#   https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/matrices
# This parses the pieces into a dgTMatrix sparse matrix object (from package `Matrix`) and should be basically equivalent to the
# Read10X function in Seurat that goes: sc <- Read10X(data.dir = "MarquinaSanchez2020/10X", gene.column = 1)
# This code takes ~2 min. to run.
barcode.path <- file.path(sc_dir, "GSE142465_MouseLTI_correctedTPM_Matrix_barcodes.txt.gz")
features.path <- file.path(sc_dir, "GSE142465_MouseLTI_correctedTPM_Matrix_genes.txt.gz")
matrix.path <- file.path(sc_dir, "GSE142465_MouseLTI_correctedTPM_Matrix.mtx.gz")
sc <- readMM(file = matrix.path)
feature.names <- read.delim(features.path, 
                            header = FALSE,
                            stringsAsFactors = FALSE)
barcode.names <- read.delim(barcode.path, 
                            header = FALSE,
                            stringsAsFactors = FALSE)
colnames(sc) <- barcode.names$V1 # sample IDs
rownames(sc) <- feature.names$V1 # gene IDs
# temp <- sc

# This dgTMatrix matrix works like so: (i,j) indexes the row of the ith gene and the jth sample and x is
# the value of that index. Missing (i,j) indices are implicitly zero!
# The alternative dgCMatrix matrix format uses (i,p) indexing: i indexes the row of the ith gene and p is
# an offset, capturing the number of non-zero entries in a given column, e.g. p[1] = 0 always, p[2] = number
# of non-zero entries in column 1, etc.
# Note that both use 0-indexing and can be translated between each other with `as(obj, "dgCMatrix")` etc.

# Filter down to the control (DMSO) samples via metadata.
sc_annot <- sc_annot[which(sc_annot$treatment == "DMSO"),]

# Filter down to consensus alpha, beta, and delta cells via metadata.
sc_annot <- sc_annot[which(sc_annot$celltype == sc_annot$celltype2),]
sc_annot <- sc_annot[which(sc_annot$celltype %in% c("Alpha", "Beta")),]

# Quality filter as in the paper source code. (See 05_PrepSpikeIns_Clean.R.) Everything identified above (DMSO x cell type) seems
# to pass QC.
sc <- sc[,colnames(sc) %in% sc_annot$rn]
cell.umis <- Matrix::colSums(sc)
sc <- sc[,cell.umis >= MIN.UMIS]
cell.genes <- Matrix::colSums(sc != 0)
sc <- sc[,cell.genes >= MIN.GENES]

# Get the sample IDs in the annotations ordered as in the count data file for easier indexing.
sc_annot <- sc_annot[order(sc_annot$rn),]
sc <- sc[,order(colnames(sc))]

sample_celltypes <- sc_annot$celltype
n_samples_sc <- ncol(sc)
n_genes_sc <- nrow(sc)

ins2_idx_sc <- which(rownames(sc) == "Ins2") # 1-indexed
gcg_idx_sc <- which(rownames(sc) == "Gcg")
gapdh_idx_sc <- which(rownames(sc) == "Gapdh")
eef2_idx_sc <- which(rownames(sc) == "Eef2")

df <- data.frame(expression = sc[ins2_idx_sc,], gene = "Ins2", celltype = sample_celltypes)
df <- rbind(df, data.frame(expression = sc[gcg_idx_sc,], gene = "Gcg", celltype = sample_celltypes))
df <- rbind(df, data.frame(expression = sc[gapdh_idx_sc,], gene = "Gapdh", celltype = sample_celltypes))
df <- rbind(df, data.frame(expression = sc[eef2_idx_sc,], gene = "Eef2", celltype = sample_celltypes))
p <- ggplot(df, aes(x = as.factor(celltype), y = expression)) +
  geom_jitter(width = 0.2) +
  facet_wrap(~ gene, scales = "free") +
  xlab("Cell type") +
  ylab("UMI counts")
if(show_images) {
  show(p)
} else {
  ggsave("02_marker_expression_in_sc.png", p, units = "in", dpi = 100, height = 4, width = 4)
}

# The total UMIs is systematically lower in alpha cells.
alpha_idx <- which(sc_annot$celltype == "Alpha") # 1-indexed
beta_idx <- which(sc_annot$celltype == "Beta")

df <- data.frame(nUMI = Matrix::colSums(sc[,alpha_idx]), celltype = "Alpha")
df <- rbind(df, data.frame(nUMI = Matrix::colSums(sc[,beta_idx]), celltype = "Beta"))
p <- ggplot(df, aes(x = as.factor(celltype), y = nUMI)) +
  geom_jitter(width = 0.2) +
  xlab("Cell type") +
  ylab("UMI counts")
if(show_images) {
  show(p)
} else {
  ggsave("03_marker_expression_in_sc.png", p, units = "in", dpi = 100, height = 4, width = 6)
}

# Repeat the first visualization with TPM-normalized data.
sc_tpm <- umi_to_tpm(sc)
df <- data.frame(expression = sc_tpm[ins2_idx_sc,], gene = "Ins2", celltype = sample_celltypes)
df <- rbind(df, data.frame(expression = sc_tpm[gcg_idx_sc,], gene = "Gcg", celltype = sample_celltypes))
df <- rbind(df, data.frame(expression = sc_tpm[gapdh_idx_sc,], gene = "Gapdh", celltype = sample_celltypes))
df <- rbind(df, data.frame(expression = sc_tpm[eef2_idx_sc,], gene = "Eef2", celltype = sample_celltypes))
p <- ggplot(df, aes(x = as.factor(celltype), y = expression)) +
  geom_jitter(width = 0.2) +
  facet_wrap(~ gene, scales = "free") +
  xlab("Cell type") +
  ylab("UMI counts")
if(show_images) {
  show(p)
} else {
  ggsave("04_marker_expression_in_sc_TPM.png", p, units = "in", dpi = 100, height = 4, width = 4)
}

# Gapdh x library size (nUMI)
df <- data.frame(x = Matrix::colSums(sc), y = sc[gapdh_idx_sc,])
p <- ggplot(df, aes(x = x, y = y)) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = "lm") +
  xlab("mUMI") +
  ylab("Gadph expression")
if(show_images) {
  show(p)
} else {
  ggsave("05_marker_expression_in_sc_TPM.png", p, units = "in", dpi = 100, height = 4, width = 4)
}

## --------------------------------------------------------------------------------------------------------------------------------
##   PLOTTING BULK VS. SINGLE-CELL
## --------------------------------------------------------------------------------------------------------------------------------

# Get intersection of genes between bulk and single-cell and chop down each data set to this intersection. We'll need to
# assess what the missing genes are becuase I'm making the assumption the gene spaces are the same here (!).
shared_genes <- sort(intersect(rownames(bulk), rownames(sc)))
n_shared <- length(shared_genes)
all_genes <- union(rownames(bulk), rownames(sc))
cat("Proportion of genes in intersection vs. union:",round(n_shared/length(all_genes), 2),"\n")
cat("Number of genes in common:",n_shared,"\n")

# Order genes (rows) equivalently in intersected bulk and single-cell data.
sc_shared <- sc[rownames(sc) %in% shared_genes,]
sc_shared <- sc_shared[order(rownames(sc_shared)),]
bulk_shared <- bulk[rownames(bulk) %in% shared_genes,]
bulk_shared <- bulk_shared[order(rownames(bulk_shared)),]

# Get mean expression for genes in each data set.
sc_expr_means <- Matrix::rowMeans(sc_shared) # nUMI
bulk_expr_means <- rowMeans(bulk_shared)

quantile_each <- 0.95
plot_idx <- sc_expr_means <= quantile(sc_expr_means, probs = c(quantile_each)) & bulk_expr_means <= quantile(bulk_expr_means, probs = c(quantile_each))
df <- data.frame(x = bulk_expr_means[plot_idx], y = sc_expr_means[plot_idx])
p <- ggplot(df, aes(x = x, y = y)) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = "lm") +
  xlab("Mean bulk expression (counts)") +
  ylab("Mean single-cell expression (UMI)")
if(show_images) {
  show(p)
} else {
  ggsave("06_bulk_vs_sc.png", p, units = "in", dpi = 100, height = 4, width = 4)
}

# Now do the TPM x TPM version.
sc_tpm <- umi_to_tpm(sc_shared)
bulk_tpm <- t(t(bulk_shared) * SCALE.FACTOR/colSums(bulk_shared))

sc_expr_means <- Matrix::rowMeans(sc_tpm)
bulk_expr_means <- rowMeans(bulk_tpm)

quantile_each <- 0.95
plot_idx <- sc_expr_means <= quantile(sc_expr_means, probs = c(quantile_each)) & bulk_expr_means <= quantile(bulk_expr_means, probs = c(quantile_each))
df <- data.frame(x = bulk_expr_means[plot_idx], y = sc_expr_means[plot_idx])
p <- ggplot(df, aes(x = x, y = y)) +
  geom_point() +
  geom_smooth(formula = y ~ x, method = "lm") +
  xlab("Mean bulk expression (counts)") +
  ylab("Mean single-cell expression (UMI)")
if(show_images) {
  show(p)
} else {
  ggsave("07_bulk_vs_sc_TPM.png", p, units = "in", dpi = 100, height = 4, width = 4)
}

## --------------------------------------------------------------------------------------------------------------------------------
##   CRUDE DIFFERENTIAL EXPRESSION CALLING
## --------------------------------------------------------------------------------------------------------------------------------

alpha <- 0.05 / n_shared

pull_bulk_expr <- function(bulk_shared, gene_idx) {
  bulk_beta <- round(unname(bulk_shared[gene_idx, colnames(bulk_shared) == "Beta"]))
  bulk_alpha <- round(unname(bulk_shared[gene_idx, colnames(bulk_shared) == "Alpha"]))
  list(beta = bulk_beta, alpha = bulk_alpha)
}

pull_sc_expr <- function(sc_shared, gene_idx) {
  sc_beta <- round(sc_shared[gene_idx, sc_beta_samples])
  sc_alpha <- round(sc_shared[gene_idx, sc_alpha_samples])
  list(beta = sc_beta, alpha = sc_alpha)
}

sc_beta_samples <- which(sc_annot$celltype == "Beta")
sc_alpha_samples <- which(sc_annot$celltype == "Alpha")

target_genes <- c(which(rownames(sc_shared) == "Ins2"),
                  which(rownames(sc_shared) == "Gcg"),
                  1:5)

target_genes <- sample(1:n_shared)[1:10]

de_calls_bulk <- c()
de_calls_sc <- c()
for(gene_idx in target_genes) {
  cat("Gene:",rownames(bulk_shared)[gene_idx],"\n")
  # Pull expression for this gene between conditions
  bulk_gene_expr <- pull_bulk_expr(bulk_shared, gene_idx)
  sc_gene_expr <- pull_sc_expr(sc_shared, gene_idx)
  # If a gene has zero variance, the model fit will fail. Usually these are all-zero expression values.
  # Mark this gene as not DE and skip.
  if(var(c(bulk_gene_expr$beta, bulk_gene_expr$alpha)) == 0) {
    de_calls_bulk <- c(de_calls_bulk, 1)
  } else {
    # Fit a NB GLM (crude but reasonable) -- bulk.
    df <- data.frame(y = c(bulk_gene_expr$alpha, bulk_gene_expr$beta), x = c(rep(0, length(bulk_gene_expr$alpha)), rep(1, length(bulk_gene_expr$beta))))
    fit <- glm.nb(formula = y ~ x, data = df)
    de_calls_bulk <- c(de_calls_bulk, summary(fit)$coef[2,4])
  }
  if(var(c(sc_gene_expr$beta, sc_gene_expr$alpha)) == 0) {
    de_calls_sc <- c(de_calls_sc, 1)
  } else {
    # Fit a NB GLM (crude but reasonable) -- single-cell.
    df <- data.frame(y = c(sc_gene_expr$alpha, sc_gene_expr$beta), x = c(rep(0, length(sc_gene_expr$alpha)), rep(1, length(sc_gene_expr$beta))))
    fit <- glm.nb(formula = y ~ x, data = df)
    de_calls_sc <- c(de_calls_sc, summary(fit)$coef[2,4])
  }
}

de_calls_bulk < alpha
de_calls_sc < alpha

par(mfrow = c(1,2))
idx <- 9
temp <- pull_sc_expr(sc_shared, target_genes[idx])
plot(c(temp$alpha, temp$beta))
temp <- pull_bulk_expr(bulk_shared, target_genes[idx])
plot(c(temp$alpha, temp$beta))








